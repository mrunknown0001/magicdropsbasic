import{bf as l,bg as x,bh as b,bi as y,bj as O,bk as S,bl as X,bm as D}from"./index-C2zOcIr5.js";function M(r,t){const e=+l(r)-+l(t);return e<0?-1:e>0?1:e}function _(r){return x(r,Date.now())}function T(r,t,e){const[s,n]=b(e==null?void 0:e.in,r,t),u=s.getFullYear()-n.getFullYear(),f=s.getMonth()-n.getMonth();return u*12+f}function Y(r){return t=>{const s=(r?Math[r]:Math.trunc)(t);return s===0?0:s}}function w(r,t){return+l(r)-+l(t)}function F(r,t){const e=l(r,t==null?void 0:t.in);return e.setHours(23,59,59,999),e}function N(r,t){const e=l(r,t==null?void 0:t.in),s=e.getMonth();return e.setFullYear(e.getFullYear(),s+1,0),e.setHours(23,59,59,999),e}function H(r,t){const e=l(r,t==null?void 0:t.in);return+F(e,t)==+N(e,t)}function v(r,t,e){const[s,n,u]=b(e==null?void 0:e.in,r,r,t),f=M(n,u),a=Math.abs(T(n,u));if(a<1)return 0;n.getMonth()===1&&n.getDate()>27&&n.setDate(30),n.setMonth(n.getMonth()-f*a);let o=M(n,u)===-f;H(s)&&a===1&&M(s,u)===1&&(o=!1);const d=f*(a-+o);return d===0?0:d}function z(r,t,e){const s=w(r,t)/1e3;return Y(e==null?void 0:e.roundingMethod)(s)}function A(r,t,e){const s=y(),n=(e==null?void 0:e.locale)??s.locale??O,u=2520,f=M(r,t);if(isNaN(f))throw new RangeError("Invalid time value");const a=Object.assign({},e,{addSuffix:e==null?void 0:e.addSuffix,comparison:f}),[o,d]=b(e==null?void 0:e.in,...f>0?[t,r]:[r,t]),m=z(d,o),I=(S(d)-S(o))/1e3,c=Math.round((m-I)/60);let h;if(c<2)return e!=null&&e.includeSeconds?m<5?n.formatDistance("lessThanXSeconds",5,a):m<10?n.formatDistance("lessThanXSeconds",10,a):m<20?n.formatDistance("lessThanXSeconds",20,a):m<40?n.formatDistance("halfAMinute",0,a):m<60?n.formatDistance("lessThanXMinutes",1,a):n.formatDistance("xMinutes",1,a):c===0?n.formatDistance("lessThanXMinutes",1,a):n.formatDistance("xMinutes",c,a);if(c<45)return n.formatDistance("xMinutes",c,a);if(c<90)return n.formatDistance("aboutXHours",1,a);if(c<X){const i=Math.round(c/60);return n.formatDistance("aboutXHours",i,a)}else{if(c<u)return n.formatDistance("xDays",1,a);if(c<D){const i=Math.round(c/X);return n.formatDistance("xDays",i,a)}else if(c<D*2)return h=Math.round(c/D),n.formatDistance("aboutXMonths",h,a)}if(h=v(d,o),h<12){const i=Math.round(c/D);return n.formatDistance("xMonths",i,a)}else{const i=h%12,g=Math.trunc(h/12);return i<3?n.formatDistance("aboutXYears",g,a):i<9?n.formatDistance("overXYears",g,a):n.formatDistance("almostXYears",g+1,a)}}function j(r,t){return A(r,_(r),t)}export{j as f};
