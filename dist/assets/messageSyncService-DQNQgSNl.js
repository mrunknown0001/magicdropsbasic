var p=Object.defineProperty;var E=(d,e,s)=>e in d?p(d,e,{enumerable:!0,configurable:!0,writable:!0,value:s}):d[e]=s;var i=(d,e,s)=>E(d,typeof e!="symbol"?e+"":e,s);import{s as w}from"./index-C2zOcIr5.js";import{ReceiveSmsOnlineScraper as $}from"./receiveSmsOnlineScraper-DkEzJxaM.js";const g=class g{constructor(){i(this,"isRunning",!1);i(this,"syncInterval",null);i(this,"SYNC_INTERVAL_MS",3*60*1e3);i(this,"MAX_RETRIES",1);i(this,"RETRY_DELAY_MS",2e3);i(this,"BATCH_SIZE",3);i(this,"STAGGER_DELAY_MS",500);i(this,"lastSyncTimes",new Map);i(this,"MIN_SYNC_INTERVAL_MS",60*1e3);i(this,"failurePatterns",new Map)}static getInstance(){return g.instance||(g.instance=new g),g.instance}startAutoSync(){if(this.isRunning){console.log("Enhanced message sync is already running");return}this.isRunning=!0,console.log("Starting enhanced automatic message sync..."),setTimeout(()=>{this.syncAllPhoneNumbers().catch(e=>{console.error("Initial enhanced sync failed:",e)})},5e3),this.syncInterval=setInterval(()=>{this.syncAllPhoneNumbers().catch(e=>{console.error("Scheduled enhanced sync failed:",e)})},this.SYNC_INTERVAL_MS),console.log(`Enhanced auto-sync started with ${this.SYNC_INTERVAL_MS/1e3}s interval`)}stopAutoSync(){if(!this.isRunning){console.log("Message sync is not running");return}this.isRunning=!1,this.syncInterval&&(clearInterval(this.syncInterval),this.syncInterval=null),console.log("Stopped automatic message sync")}isAutoSyncRunning(){return this.isRunning}async syncAllPhoneNumbers(){console.log("Starting enhanced sync of all receive-sms-online.info phone numbers...");const e={totalPhoneNumbers:0,successfulSyncs:0,failedSyncs:0,totalNewMessages:0,errors:[],serviceAccessible:!0,lastSyncTime:new Date().toISOString()};try{const{data:s,error:n}=await w.from("phone_numbers").select("*").eq("provider","receive_sms_online").eq("status","active").not("external_url","is",null);if(n)throw new Error(`Failed to fetch phone numbers: ${n.message}`);if(!s||s.length===0)return console.log("No receive-sms-online.info phone numbers found for syncing"),e;const r=Date.now(),a=s.filter(o=>{const l=this.lastSyncTimes.get(o.id),t=this.failurePatterns.get(o.id);if(l&&r-l<this.MIN_SYNC_INTERVAL_MS)return console.log(`Skipping ${o.phone_number} - synced ${Math.round((r-l)/1e3)}s ago`),!1;if(t&&t.count>3){const f=Math.min(t.count*60*1e3,18e5);if(r-t.lastFailure<f)return console.log(`Skipping ${o.phone_number} - in failure backoff (${t.count} failures)`),!1}return!0});if(e.totalPhoneNumbers=s.length,console.log(`Found ${s.length} phone numbers, ${a.length} will be synced`),a.length===0)return console.log("All phone numbers are in cooldown or backoff periods"),e;const c=this.createBatches(a,this.BATCH_SIZE);console.log(`Processing ${a.length} phone numbers in ${c.length} batches of ${this.BATCH_SIZE}`);let y=!0;for(let o=0;o<c.length;o++){const l=c[o];console.log(`Processing enhanced batch ${o+1}/${c.length} with ${l.length} phone numbers`),l.forEach(u=>this.lastSyncTimes.set(u.id,r));const t=l.map(u=>this.syncPhoneNumberMessages(u));if((await Promise.allSettled(t)).forEach((u,b)=>{const m=l[b];if(u.status==="fulfilled"){const h=u.value;if(h.success)e.successfulSyncs++,e.totalNewMessages+=h.newMessagesCount,this.failurePatterns.delete(m.id),console.log(`✓ ${m.phone_number}: ${h.newMessagesCount} new messages`);else{e.failedSyncs++;const _=`${m.phone_number}: ${h.error}`;e.errors.push(_),this.trackFailure(m.id,h.error||"Unknown error"),h.debugInfo&&!h.debugInfo.serviceAccessible&&(e.serviceAccessible=!1,y&&(console.warn("⚠️ Service accessibility issue detected - may affect all numbers"),y=!1)),console.log(`✗ ${_}`)}}else{e.failedSyncs++;const h=`${m.phone_number}: ${u.reason}`;e.errors.push(h),this.trackFailure(m.id,String(u.reason)),console.log(`✗ ${h}`)}}),o<c.length-1){const u=e.serviceAccessible?this.STAGGER_DELAY_MS:this.STAGGER_DELAY_MS*2;console.log(`Waiting ${u}ms before next batch...`),await this.delay(u)}}return console.log("Enhanced sync completed:"),console.log(`- Total numbers: ${e.totalPhoneNumbers}`),console.log(`- Successful syncs: ${e.successfulSyncs}`),console.log(`- Failed syncs: ${e.failedSyncs}`),console.log(`- New messages: ${e.totalNewMessages}`),console.log(`- Service accessible: ${e.serviceAccessible}`),e.errors.length>0&&(console.log("Errors encountered:"),e.errors.forEach(o=>console.log(`  - ${o}`))),e}catch(s){return console.error("Error during enhanced sync:",s),e.errors.push(s instanceof Error?s.message:"Unknown error"),e.serviceAccessible=!1,e}}createBatches(e,s){const n=[];for(let r=0;r<e.length;r+=s)n.push(e.slice(r,r+s));return n}async syncPhoneNumberMessages(e){const s={success:!1,phoneNumberId:e.id,newMessagesCount:0};try{if(!e.external_url)throw new Error("No external URL configured for phone number");console.log(`Syncing messages for ${e.phone_number}...`);const n=await this.scrapeWithRetry(e.external_url,this.MAX_RETRIES);if(s.debugInfo=n.debugInfo,!n.success)throw new Error(n.error||"Scraping failed");if(n.messages.length===0)return console.log(`No messages found for ${e.phone_number}`),s.success=!0,s;const{data:r,error:a}=await w.from("phone_messages").select("sender, message, received_at").eq("phone_number_id",e.id);if(a)throw new Error(`Failed to fetch existing messages: ${a.message}`);const c=n.messages.filter(t=>!(r!=null&&r.some(f=>f.sender===t.sender&&f.message===t.message&&Math.abs(new Date(f.received_at).getTime()-new Date(t.received_at).getTime())<6e4)));if(c.length===0)return console.log(`No new messages for ${e.phone_number} (${n.messages.length} scraped, all duplicates)`),s.success=!0,s;const y=c.map(t=>({phone_number_id:e.id,sender:t.sender,message:t.message,received_at:t.received_at,message_source:"scraping",raw_html:t.raw_html})),{error:o}=await w.from("phone_messages").insert(y);if(o)throw new Error(`Failed to insert messages: ${o.message}`);const{error:l}=await w.from("phone_numbers").update({last_scraped_at:new Date().toISOString()}).eq("id",e.id);return l&&console.warn(`Failed to update last_scraped_at for ${e.phone_number}:`,l),console.log(`✓ Successfully synced ${c.length} new messages for ${e.phone_number}`),s.success=!0,s.newMessagesCount=c.length,s}catch(n){const r=n instanceof Error?n.message:"Unknown error";return console.error(`Failed to sync messages for ${e.phone_number}:`,r),s.error=r,s}}trackFailure(e,s){const n=this.failurePatterns.get(e)||{count:0,lastFailure:0,reason:""};n.count++,n.lastFailure=Date.now(),n.reason=s,this.failurePatterns.set(e,n)}async scrapeWithRetry(e,s=this.MAX_RETRIES){let n;for(let r=1;r<=s+1;r++)try{console.log(`Scraping attempt ${r}/${s+1} for URL`);const a=await $.scrapeMessages(e);if(a.success)return r>1&&console.log(`Scraping succeeded on attempt ${r}`),a;throw new Error(a.error||"Scraping returned unsuccessful result")}catch(a){if(n=a instanceof Error?a:new Error("Unknown error"),console.warn(`Scraping attempt ${r} failed:`,n.message),r<=s){const c=this.RETRY_DELAY_MS*r;console.log(`Waiting ${c}ms before retry...`),await this.delay(c)}}throw n}delay(e){return new Promise(s=>setTimeout(s,e))}getSyncInfo(){return{isRunning:this.isRunning,intervalMs:this.SYNC_INTERVAL_MS}}async syncPhoneNumberById(e){try{const{data:s,error:n}=await w.from("phone_numbers").select("*").eq("id",e).eq("provider","receive_sms_online").single();if(n)throw new Error(`Failed to fetch phone number: ${n.message}`);if(!s)throw new Error("Phone number not found or not a receive-sms-online.info number");return await this.syncPhoneNumberMessages(s)}catch(s){return{success:!1,phoneNumberId:e,newMessagesCount:0,error:s instanceof Error?s.message:"Unknown error"}}}};i(g,"instance");let S=g;const v=S.getInstance();export{S as MessageSyncService,v as messageSyncService};
